// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const countLicenses = `-- name: CountLicenses :one
SELECT COUNT(*) FROM licenses
`

func (q *Queries) CountLicenses(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countLicenses)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countProjectsForTenant = `-- name: CountProjectsForTenant :one
SELECT COUNT(*) FROM projects WHERE tenant_id = ?
`

func (q *Queries) CountProjectsForTenant(ctx context.Context, tenantID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countProjectsForTenant, tenantID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteSession = `-- name: DeleteSession :exec
DELETE FROM sessions WHERE token_hash = ?
`

func (q *Queries) DeleteSession(ctx context.Context, tokenHash string) error {
	_, err := q.db.ExecContext(ctx, deleteSession, tokenHash)
	return err
}

const getDefaultTenant = `-- name: GetDefaultTenant :one
SELECT id FROM tenants WHERE is_default = 1 LIMIT 1
`

func (q *Queries) GetDefaultTenant(ctx context.Context) (string, error) {
	row := q.db.QueryRowContext(ctx, getDefaultTenant)
	var id string
	err := row.Scan(&id)
	return id, err
}

const getLicense = `-- name: GetLicense :one
SELECT max_projects_per_tenant, whatsapp_enabled, subclient_enabled
FROM licenses
LIMIT 1
`

type GetLicenseRow struct {
	MaxProjectsPerTenant int64 `json:"max_projects_per_tenant"`
	WhatsappEnabled      int64 `json:"whatsapp_enabled"`
	SubclientEnabled     int64 `json:"subclient_enabled"`
}

func (q *Queries) GetLicense(ctx context.Context) (GetLicenseRow, error) {
	row := q.db.QueryRowContext(ctx, getLicense)
	var i GetLicenseRow
	err := row.Scan(&i.MaxProjectsPerTenant, &i.WhatsappEnabled, &i.SubclientEnabled)
	return i, err
}

const getProjectByTenant = `-- name: GetProjectByTenant :one
SELECT subclient_enabled, whatsapp_enabled
FROM projects
WHERE id = ? AND tenant_id = ?
`

type GetProjectByTenantParams struct {
	ID       string `json:"id"`
	TenantID string `json:"tenant_id"`
}

type GetProjectByTenantRow struct {
	SubclientEnabled int64 `json:"subclient_enabled"`
	WhatsappEnabled  int64 `json:"whatsapp_enabled"`
}

func (q *Queries) GetProjectByTenant(ctx context.Context, arg GetProjectByTenantParams) (GetProjectByTenantRow, error) {
	row := q.db.QueryRowContext(ctx, getProjectByTenant, arg.ID, arg.TenantID)
	var i GetProjectByTenantRow
	err := row.Scan(&i.SubclientEnabled, &i.WhatsappEnabled)
	return i, err
}

const getSession = `-- name: GetSession :one
SELECT user_id, scope_type, scope_id, expires_at
FROM sessions
WHERE token_hash = ?
`

type GetSessionRow struct {
	UserID    string    `json:"user_id"`
	ScopeType string    `json:"scope_type"`
	ScopeID   string    `json:"scope_id"`
	ExpiresAt time.Time `json:"expires_at"`
}

func (q *Queries) GetSession(ctx context.Context, tokenHash string) (GetSessionRow, error) {
	row := q.db.QueryRowContext(ctx, getSession, tokenHash)
	var i GetSessionRow
	err := row.Scan(
		&i.UserID,
		&i.ScopeType,
		&i.ScopeID,
		&i.ExpiresAt,
	)
	return i, err
}

const getSubclientByDomain = `-- name: GetSubclientByDomain :one
SELECT id, project_id, (SELECT tenant_id FROM projects WHERE id = subclients.project_id) as tenant_id
FROM subclients
WHERE domain = ?
`

type GetSubclientByDomainRow struct {
	ID        string `json:"id"`
	ProjectID string `json:"project_id"`
	TenantID  string `json:"tenant_id"`
}

func (q *Queries) GetSubclientByDomain(ctx context.Context, domain string) (GetSubclientByDomainRow, error) {
	row := q.db.QueryRowContext(ctx, getSubclientByDomain, domain)
	var i GetSubclientByDomainRow
	err := row.Scan(&i.ID, &i.ProjectID, &i.TenantID)
	return i, err
}

const getSubclientByID = `-- name: GetSubclientByID :one
SELECT domain FROM subclients WHERE id = ?
`

func (q *Queries) GetSubclientByID(ctx context.Context, id string) (string, error) {
	row := q.db.QueryRowContext(ctx, getSubclientByID, id)
	var domain string
	err := row.Scan(&domain)
	return domain, err
}

const getSubclientFullByID = `-- name: GetSubclientFullByID :one
SELECT subclients.id, subclients.project_id, (SELECT tenant_id FROM projects WHERE id = subclients.project_id) as tenant_id
FROM subclients
WHERE subclients.id = ?
`

type GetSubclientFullByIDRow struct {
	ID        string `json:"id"`
	ProjectID string `json:"project_id"`
	TenantID  string `json:"tenant_id"`
}

func (q *Queries) GetSubclientFullByID(ctx context.Context, id string) (GetSubclientFullByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getSubclientFullByID, id)
	var i GetSubclientFullByIDRow
	err := row.Scan(&i.ID, &i.ProjectID, &i.TenantID)
	return i, err
}

const getSubclientUser = `-- name: GetSubclientUser :one
SELECT id, role, password_hash
FROM users
WHERE subclient_id = ? AND username = ?
`

type GetSubclientUserParams struct {
	SubclientID sql.NullString `json:"subclient_id"`
	Username    string         `json:"username"`
}

type GetSubclientUserRow struct {
	ID           string         `json:"id"`
	Role         string         `json:"role"`
	PasswordHash sql.NullString `json:"password_hash"`
}

func (q *Queries) GetSubclientUser(ctx context.Context, arg GetSubclientUserParams) (GetSubclientUserRow, error) {
	row := q.db.QueryRowContext(ctx, getSubclientUser, arg.SubclientID, arg.Username)
	var i GetSubclientUserRow
	err := row.Scan(&i.ID, &i.Role, &i.PasswordHash)
	return i, err
}

const getTenantByDomain = `-- name: GetTenantByDomain :one
SELECT id FROM tenants WHERE domain = ?
`

func (q *Queries) GetTenantByDomain(ctx context.Context, domain string) (string, error) {
	row := q.db.QueryRowContext(ctx, getTenantByDomain, domain)
	var id string
	err := row.Scan(&id)
	return id, err
}

const getTenantByID = `-- name: GetTenantByID :one
SELECT domain FROM tenants WHERE id = ?
`

func (q *Queries) GetTenantByID(ctx context.Context, id string) (string, error) {
	row := q.db.QueryRowContext(ctx, getTenantByID, id)
	var domain string
	err := row.Scan(&domain)
	return domain, err
}

const getTenantUser = `-- name: GetTenantUser :one
SELECT id, role, password_hash
FROM users
WHERE tenant_id = ? AND subclient_id IS NULL AND username = ?
`

type GetTenantUserParams struct {
	TenantID sql.NullString `json:"tenant_id"`
	Username string         `json:"username"`
}

type GetTenantUserRow struct {
	ID           string         `json:"id"`
	Role         string         `json:"role"`
	PasswordHash sql.NullString `json:"password_hash"`
}

func (q *Queries) GetTenantUser(ctx context.Context, arg GetTenantUserParams) (GetTenantUserRow, error) {
	row := q.db.QueryRowContext(ctx, getTenantUser, arg.TenantID, arg.Username)
	var i GetTenantUserRow
	err := row.Scan(&i.ID, &i.Role, &i.PasswordHash)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT username, role, IFNULL(tenant_id, '') as tenant_id, IFNULL(project_id, '') as project_id, IFNULL(subclient_id, '') as subclient_id
FROM users
WHERE id = ?
`

type GetUserByIDRow struct {
	Username    string      `json:"username"`
	Role        string      `json:"role"`
	TenantID    interface{} `json:"tenant_id"`
	ProjectID   interface{} `json:"project_id"`
	SubclientID interface{} `json:"subclient_id"`
}

func (q *Queries) GetUserByID(ctx context.Context, id string) (GetUserByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getUserByID, id)
	var i GetUserByIDRow
	err := row.Scan(
		&i.Username,
		&i.Role,
		&i.TenantID,
		&i.ProjectID,
		&i.SubclientID,
	)
	return i, err
}

const insertLicense = `-- name: InsertLicense :exec
INSERT INTO licenses (id, license_key, max_projects_per_tenant, whatsapp_enabled, subclient_enabled, tenant_name)
VALUES (?, ?, ?, ?, ?, ?)
`

type InsertLicenseParams struct {
	ID                   string `json:"id"`
	LicenseKey           string `json:"license_key"`
	MaxProjectsPerTenant int64  `json:"max_projects_per_tenant"`
	WhatsappEnabled      int64  `json:"whatsapp_enabled"`
	SubclientEnabled     int64  `json:"subclient_enabled"`
	TenantName           string `json:"tenant_name"`
}

func (q *Queries) InsertLicense(ctx context.Context, arg InsertLicenseParams) error {
	_, err := q.db.ExecContext(ctx, insertLicense,
		arg.ID,
		arg.LicenseKey,
		arg.MaxProjectsPerTenant,
		arg.WhatsappEnabled,
		arg.SubclientEnabled,
		arg.TenantName,
	)
	return err
}

const insertProject = `-- name: InsertProject :exec
INSERT INTO projects (id, tenant_id, name, whatsapp_enabled, subclient_enabled, created_by_user_id, created_at)
VALUES (?, ?, ?, ?, ?, ?, ?)
`

type InsertProjectParams struct {
	ID               string    `json:"id"`
	TenantID         string    `json:"tenant_id"`
	Name             string    `json:"name"`
	WhatsappEnabled  int64     `json:"whatsapp_enabled"`
	SubclientEnabled int64     `json:"subclient_enabled"`
	CreatedByUserID  string    `json:"created_by_user_id"`
	CreatedAt        time.Time `json:"created_at"`
}

func (q *Queries) InsertProject(ctx context.Context, arg InsertProjectParams) error {
	_, err := q.db.ExecContext(ctx, insertProject,
		arg.ID,
		arg.TenantID,
		arg.Name,
		arg.WhatsappEnabled,
		arg.SubclientEnabled,
		arg.CreatedByUserID,
		arg.CreatedAt,
	)
	return err
}

const insertSession = `-- name: InsertSession :exec
INSERT INTO sessions (id, user_id, scope_type, scope_id, token_hash, host, expires_at)
VALUES (?, ?, ?, ?, ?, ?, ?)
`

type InsertSessionParams struct {
	ID        string         `json:"id"`
	UserID    string         `json:"user_id"`
	ScopeType string         `json:"scope_type"`
	ScopeID   string         `json:"scope_id"`
	TokenHash string         `json:"token_hash"`
	Host      sql.NullString `json:"host"`
	ExpiresAt time.Time      `json:"expires_at"`
}

func (q *Queries) InsertSession(ctx context.Context, arg InsertSessionParams) error {
	_, err := q.db.ExecContext(ctx, insertSession,
		arg.ID,
		arg.UserID,
		arg.ScopeType,
		arg.ScopeID,
		arg.TokenHash,
		arg.Host,
		arg.ExpiresAt,
	)
	return err
}

const insertSubclient = `-- name: InsertSubclient :exec
INSERT INTO subclients (id, project_id, name, domain, created_by_user_id)
VALUES (?, ?, ?, ?, ?)
`

type InsertSubclientParams struct {
	ID              string `json:"id"`
	ProjectID       string `json:"project_id"`
	Name            string `json:"name"`
	Domain          string `json:"domain"`
	CreatedByUserID string `json:"created_by_user_id"`
}

func (q *Queries) InsertSubclient(ctx context.Context, arg InsertSubclientParams) error {
	_, err := q.db.ExecContext(ctx, insertSubclient,
		arg.ID,
		arg.ProjectID,
		arg.Name,
		arg.Domain,
		arg.CreatedByUserID,
	)
	return err
}

const insertTenant = `-- name: InsertTenant :exec
INSERT INTO tenants (id, name, domain, is_default)
VALUES (?, ?, ?, 1)
`

type InsertTenantParams struct {
	ID     string `json:"id"`
	Name   string `json:"name"`
	Domain string `json:"domain"`
}

func (q *Queries) InsertTenant(ctx context.Context, arg InsertTenantParams) error {
	_, err := q.db.ExecContext(ctx, insertTenant, arg.ID, arg.Name, arg.Domain)
	return err
}

const insertUser = `-- name: InsertUser :exec
INSERT INTO users (id, tenant_id, username, password_hash, role, source)
VALUES (?, ?, ?, ?, ?, ?)
`

type InsertUserParams struct {
	ID           string         `json:"id"`
	TenantID     sql.NullString `json:"tenant_id"`
	Username     string         `json:"username"`
	PasswordHash sql.NullString `json:"password_hash"`
	Role         string         `json:"role"`
	Source       string         `json:"source"`
}

func (q *Queries) InsertUser(ctx context.Context, arg InsertUserParams) error {
	_, err := q.db.ExecContext(ctx, insertUser,
		arg.ID,
		arg.TenantID,
		arg.Username,
		arg.PasswordHash,
		arg.Role,
		arg.Source,
	)
	return err
}

const listProjects = `-- name: ListProjects :many
SELECT id, tenant_id, name, whatsapp_enabled, subclient_enabled, created_by_user_id, created_at
FROM projects
WHERE tenant_id = ?
ORDER BY created_at DESC
`

func (q *Queries) ListProjects(ctx context.Context, tenantID string) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, listProjects, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Name,
			&i.WhatsappEnabled,
			&i.SubclientEnabled,
			&i.CreatedByUserID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSubclients = `-- name: ListSubclients :many
SELECT id, project_id, name, domain
FROM subclients
WHERE project_id = ?
ORDER BY created_at DESC
`

type ListSubclientsRow struct {
	ID        string `json:"id"`
	ProjectID string `json:"project_id"`
	Name      string `json:"name"`
	Domain    string `json:"domain"`
}

func (q *Queries) ListSubclients(ctx context.Context, projectID string) ([]ListSubclientsRow, error) {
	rows, err := q.db.QueryContext(ctx, listSubclients, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListSubclientsRow
	for rows.Next() {
		var i ListSubclientsRow
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.Name,
			&i.Domain,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertWhatsappUser = `-- name: UpsertWhatsappUser :exec
INSERT INTO users (id, tenant_id, project_id, username, role, source)
VALUES (?, ?, ?, ?, ?, ?)
ON CONFLICT (project_id, subclient_id, username) DO NOTHING
`

type UpsertWhatsappUserParams struct {
	ID        string         `json:"id"`
	TenantID  sql.NullString `json:"tenant_id"`
	ProjectID sql.NullString `json:"project_id"`
	Username  string         `json:"username"`
	Role      string         `json:"role"`
	Source    string         `json:"source"`
}

func (q *Queries) UpsertWhatsappUser(ctx context.Context, arg UpsertWhatsappUserParams) error {
	_, err := q.db.ExecContext(ctx, upsertWhatsappUser,
		arg.ID,
		arg.TenantID,
		arg.ProjectID,
		arg.Username,
		arg.Role,
		arg.Source,
	)
	return err
}

const updateProject = `-- name: UpdateProject :exec
UPDATE projects
SET name = ?
WHERE id = ? AND tenant_id = ?
`

func (q *Queries) UpdateProject(ctx context.Context, arg UpdateProjectParams) error {
	_, err := q.db.ExecContext(ctx, updateProject, arg.Name, arg.ID, arg.TenantID)
	return err
}

const deleteProject = `-- name: DeleteProject :exec
DELETE FROM projects
WHERE id = ? AND tenant_id = ?
`

func (q *Queries) DeleteProject(ctx context.Context, arg DeleteProjectParams) error {
	_, err := q.db.ExecContext(ctx, deleteProject, arg.ID, arg.TenantID)
	return err
}
