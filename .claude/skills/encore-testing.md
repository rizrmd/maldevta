# Encore Testing, Middleware & Validation

## Testing

Run tests with: `encore test ./...` (run from `apps/` directory)
Supports all standard go test flags. Built-in tracing at localhost:9400.

### When to Write Tests

- Business logic with conditional paths
- Data transformation and validation
- Error handling and edge cases
- Integration points between services
- Public API contracts

### When NOT to Write Tests

- Simple getters/setters
- Trivial one-liners
- Purely declarative configuration
- Code generated by tools
- Framework glue code with no business logic

### Test Hierarchy

1. Unit tests: Test isolated functions/methods with mocks for dependencies
2. Integration tests: Test service interactions with real database/cache
3. E2E tests: Test full user flows across multiple services (rarely needed)

### What to Test

- Happy path: Typical use case works correctly
- Error paths: Proper error handling and messages
- Edge cases: Empty inputs, boundary values, nil pointers
- Business rules: Validation logic, state transitions
- External API contracts: Request/response formats

### What NOT to Test

- Third-party library behavior (trust their tests)
- Internal implementation details (tests break on refactors)
- Database schema directly (test via migrations and queries)
- Framework features (Encore handles auth, routing, etc.)

### Test File Placement

- `service.go` â†’ `service_test.go` (same package)
- Use package-level comments to describe test groupings
- Table-driven tests for multiple similar cases

### Test Naming Conventions

```go
func Test<Service>_<API>_<Scenario>(t *testing.T)
// Examples:
// TestTodo_Create_Success
// TestTodo_Create_DuplicateID
// TestTodo_Get_NotFound
```

### Database Testing

- Use `et.NewTestDatabase()` instead of mocking
- Automatic setup in separate cluster, optimized for speed
- Temporary databases: Creates isolated, fully migrated DB
- Run migrations automatically on setup
- Tests are independent and can run in parallel

**Example database test:**
```go
func TestTodoService_Create(t *testing.T) {
    t.Parallel()
    testDB := et.NewTestDatabase()

    svc := &Service{db: testDB}

    todo, err := svc.Create(ctx, &CreateParams{Title: "Buy milk"})
    if err != nil {
        t.Fatalf("failed to create todo: %v", err)
    }

    if todo.Title != "Buy milk" {
        t.Errorf("expected title 'Buy milk', got %q", todo.Title)
    }
}
```

### Service Structs

- Lazy initialization, instance sharing between tests
- Isolate with: `et.EnableServiceInstanceIsolation()`
- Consider interface extraction for easier mocking of dependencies

### Test Organization

```go
// table-driven test for multiple scenarios
func TestTodoService_Create(t *testing.T) {
    t.Parallel()

    tests := []struct {
        name    string
        params  *CreateParams
        wantErr error
    }{
        {
            name:   "valid todo",
            params: &CreateParams{Title: "Test todo"},
        },
        {
            name:    "empty title",
            params:  &CreateParams{Title: ""},
            wantErr: &errs.Error{Code: errs.InvalidArgument},
        },
    }

    for _, tt := range tests {
        tt := tt
        t.Run(tt.name, func(t *testing.T) {
            svc := setupTestService(t)
            _, err := svc.Create(ctx, tt.params)

            if tt.wantErr != nil {
                if !errs.Matches(err, tt.wantErr) {
                    t.Errorf("expected error code %v, got %v", tt.wantErr, err)
                }
            } else if err != nil {
                t.Errorf("unexpected error: %v", err)
            }
        })
    }
}
```

### Running Tests (from apps/ directory)

- Single package: `encore test ./path/to/service`
- All tests: `encore test ./...`
- With race detection: `encore test -race ./...`
- Verbose output: `encore test -v ./...`
- Specific test: `encore test -run TestTodo_Create ./...`
- Run benchmarks: `encore test -bench=. ./...`

## Mocking

Built-in mocking for isolated testing.

### When to Mock vs Real Dependencies

- MOCK: External APIs (Stripe, GitHub, third-party services)
- MOCK: Email providers (SendGrid, SES, Mailgun)
- MOCK: SMS/messaging services (Twilio)
- MOCK: Non-deterministic operations (time, randomness)
- MOCK: Slow or expensive operations (large computations, file I/O for unit tests)
- DO NOT MOCK: Database queries (use et.NewTestDatabase instead)
- DO NOT MOCK: Cache operations (test real behavior with et.NewRedisCluster)
- DO NOT MOCK: Pub/Sub topics (use et.Topic for inspection)
- DO NOT MOCK: Business logic within your app

### Anti-patterns to Avoid

- Over-mocking: Mock too many layers, tests become brittle and meaningless
- Mocking the system under test: Don't mock what you're trying to test
- Tight coupling to implementation: Mock should verify behavior, not internal details
- Ignoring error paths: Tests should cover both success and failure scenarios

### Choosing Mock Level

- Use `et.MockEndpoint`: For a specific API call in a single test
- Use `TestMain + et.MockEndpoint`: For an API used across multiple tests in a package
- Use `et.MockService`: When replacing entire service behavior
- Use `et.MockService[Interface]`: Type-safe mocking with interface contracts

### Mocking Examples

```go
// Mock endpoint for single test
func Test_Something(t *testing.T) {
    t.Parallel()
    et.MockEndpoint(products.GetPrice, func(ctx context.Context, p *products.PriceParams) (*products.PriceResponse, error) {
        return &products.PriceResponse{Price: 100}, nil
    })
}

// Mock endpoint for all tests in package
func TestMain(m *testing.M) {
    et.MockEndpoint(products.GetPrice, func(ctx context.Context, p *products.PriceParams) (*products.PriceResponse, error) {
        return &products.PriceResponse{Price: 100}, nil
    })
    os.Exit(m.Run())
}

// Mock entire service
et.MockService("products", &products.Service{
    SomeField: "a testing value",
})

// Type-safe service mocking
et.MockService[products.Interface]("products", &myMockObject{})
```

## Middleware

Reusable code running before/after API requests.

```go
//encore:middleware global target=all
func ValidationMiddleware(req middleware.Request, next middleware.Next) middleware.Response {
    payload := req.Data().Payload
    if validator, ok := payload.(interface { Validate() error }); ok {
        if err := validator.Validate(); err != nil {
            err = errs.WrapCode(err, errs.InvalidArgument, "validation failed")
            return middleware.Response{Err: err}
        }
    }
    return next(req)
}

// With dependency injection
//encore:middleware target=all
func (s *Service) MyMiddleware(req middleware.Request, next middleware.Next) middleware.Response {
    // Implementation
}

// Tag-based targeting
//encore:middleware target=tag:cache
func CachingMiddleware(req middleware.Request, next middleware.Next) middleware.Response {
    // ...
}

//encore:api public method=GET path=/user/:id tag:cache
func GetUser(ctx context.Context, id string) (*User, error) {
    // Implementation
}
```

**Ordering**: Global before service-specific, lexicographic by filename.

## Validation

Automatic request validation via `Validate()` method.

```go
type MyRequest struct {
    Email string
}

func (r *MyRequest) Validate() error {
    if !isValidEmail(r.Email) {
        return &errs.Error{Code: errs.InvalidArgument, Message: "invalid email"}
    }
    return nil
}
```

Validation runs after deserialization, before handler. Non-errs.Error errors become InvalidArgument (HTTP 400).

## CGO

Enable in `encore.app`:
```json
{
  "id": "my-app-id",
  "build": {
    "cgo_enabled": true
  }
}
```

Uses Ubuntu builder with gcc. Libraries must support static linking.
